---
title: "Environments"
description: |
  Manage environments for data science.
site: distill::distill_website
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(DiagrammeR)
```

# Intro

Great data science work should be reproducible. Being able to repeat experiments is the foundation of all science. Reproducing work is also critical for buisness applications: scheduled reporting, team collaboration, project validation. In order to reproduce work done in R, you need to communicate 3 things: your code, your reasoning, and the environment where your code runs. There are many excellent tools and strategies for managing code - Git - and communicating methods - R Markdown. Unfortunately, environments are often neglected.  

This website breaks down common use cases and strategies for solving them. It also explains the components that make up a data science environment. It is important to remember that no single tool will solve every environment challenge. Instead, you or your team should discuss how different tools working together can meet your requirements.

```{r fig.cap="R Packages Flow Through An Organization", layout="l-body-outset", echo=FALSE}
grViz("
digraph boxes_and_circles {
  node [shape = box]
  CRAN; GitHub; Internal; 'Local Repository'
  
  node [shape = egg]
  'Project 1'; 'Project 2'; API; 'Shiny App'; 'ETL Job'; 'Shared Project'; 'Docker Container'
  
  node [shape = oval]
  Desktop; 'Dev Server'; Production
  
  subgraph legend {
  node [fillcolor = grey, style = filled, shape = box]
  'Package Source / Binary'
  node [fillcolor = grey, style = filled, shape = egg]
  'Library'
  node [fillcolor = grey, style = filled, shape = oval]
  'Installed Cache'
  
  'Package Source / Binary' -> 'Installed Cache'
  'Installed Cache' -> 'Library'
  }

CRAN->'Local Repository'
GitHub->'Local Repository'
Internal->'Local Repository'
'Local Repository' -> Desktop
'Local Repository' -> 'Docker Container'
'Local Repository' -> 'Dev Server'
'Local Repository' -> Production
Desktop -> 'Project 1'
Desktop -> 'Project 2'
Production -> API
Production -> 'Shiny App'
Production -> 'ETL Job'
'Dev Server' ->  'Shared Project'
}
")
```

### 3 Signs You Need A Better Strategy

While everyone should have a plan for reproducible environments, here are a few anti-patterns to suggest environment management has gone wrong:

- Code that used to run no longer runs, but the code has not changed
- You are afraid to upgrade or install a new package, because it might break your code or someone else's
- Typing `install.packages` in your environment doesn't do anything

It is also important to recognize that not everyone needs the same approach or concern for reproducibility. If you're a student reporting an error to your professor, capturing your `sessionInfo()` may be all you need. In contrast, a statistician working on a clinical trial will need a robust framework for recreating their environment. **Reproducibility is not binary!**

If you're an individual data scientist, there are two things you should do **before you continue any further** with environment management: [learn about RStudio Projects](https://r4ds.had.co.nz/workflow-projects.html#rstudio-projects) and [use version control](https://happygitwithr.com/).

```{r spectrum, echo = FALSE, layout="l-page", fig.cap="Strategies for reproducibility fall on a spectrum. One side is not better than the other. Pick based on your goals.", fig.height=5, fig.width=8}
library(ggplot2)
library(tibble)
timeline <- tribble(
  ~x, ~y, 
  0, 1,
  16, 1
)

labels <- tribble(
  ~x, ~y, ~label,
  0, 1.1, "No Strategy",
  4, 1.1, "Aware & Record",
  8, 1.1, "Easy Sharing",
  12, 1.1, "Record & Restore",
  16, 1.1, "Validated",
)

details <- tribble(
  ~x, ~y, ~label,
  0, 0.9, "scary upgrades \n no sharing \n old stuff is borked",
  4, 0.9, "reprex \n sessioninfo()", 
  8, 0.9, "site library \n frozen repo",
  12, 0.9, "renv",
  16, 0.9, "internal repo \ncustom tests"
)


ggplot() + 
  geom_path(data = timeline, aes(x,y),  color = "black") + 
  geom_label(data = labels, aes(x,y,label=label)) + 
  geom_text(data = details, aes(x,y,label=label)) + 
  theme_minimal() + 
  scale_x_continuous(breaks = NULL, limits = c(-2,17)) + 
  scale_y_continuous(breaks = NULL, limits = c(0.5, 1.5)) + 
  labs(
    title = NULL,
    x = NULL,
    y = NULL
  )

```

### Where to go next?

Check out [Getting Started](./index.html#getting-started) for a strategy that fits most users, or review the [full set of strategies](./reproduce.html). Alternatively, look for your use case: [upgrading](./upgrades.html), [picking packages](./picking), [validation](./validation.html), [collaboration](./collaborate.html), [production deployments](./deploy.html). Interested in exploring the architecture first? Read about the [components of an environment](./index.html#what-makes-up-an-environment).

# Getting Started

Not everyone needs the same environment management strategy. This section covers an approach that will greatly increase the chances your work can be reproduced. Teams of R users, R users working within an organization, or new R users, may find a [different strategy](./reproduce.html) more appropriate.

```{r fig.cap="Simple Workflow for Reproducible Environments", layout="l-body", echo=FALSE}
grViz("
digraph renv {
  graph [layout = dot
         rankdir = LR]
  node [shape = box]
  '1. Create a Project'; 'Write Code'; '2. Install Packages'; '3. Snapshot'; '4. Restore'
  
  '1. Create a Project'->'Write Code'
  'Write Code'->'2. Install Packages' 
  '2. Install Packages' -> 'Write Code'
  'Write Code'->'3. Snapshot'
  '3. Snapshot'->'4. Restore'
  
}      
")
```

<aside>
1. `renv::create()`
2. `pak::pkg_install(...)`
3. `renv::snapshot()`
4. `renv::restore()`
</aside>


### Step 1: Create a Project Library

A *key* to package management is to isolate projects from one another. This allows you to upgrade or add packages for one project without breaking other work. New to projects? [Start here!](https://r4ds.had.co.nz/workflow-projects.html#rstudio-projects) Once you have a project, isolating project dependencies is done using the [`renv` package](https://github.com/rstudio/renv)^[What happened to `packrat`? This is a great question, because it means you've thought about environment management before! `renv` is the next generation of packrat.].

Whether you are in an existing project or just starting a brand new project, use:

```{r eval=FALSE}
renv::init()
```


Behind the scenes, `renv` works by creating a new library. Interested? [Learn more about libraries](./libraries.html).

### Step 2: Install and Use Packages 

With the project configured, you can now install and use packages as you normally would. If you are working on your Desktop or a shared server, we recommend using [`pak`](https://github.com/r-lib/pak) to make installing packages faster and safer. In contrast, if you are in a lightweight environment like Docker, you may prefer to use [`remotes`](https://github.com/r-lib/remotes). We recommend [learning more about package installation](./installation.html).

```{r eval=FALSE}
# You can use install.packages
install.packages('ggplot2')

# But we recommend using pak in interactive settings
pak::pkg_install('ggplot2')

# Or use remotes if you're working on an automated script or 
# in a lightweight environment like Docker
remotes::install_cran('ggplot2')
```

Reference packages just how you normally would!

```{r eval = FALSE}
library(ggplot2)
```

Don't have access to install packages yourself? [Check out repositories](./repositories) to learn more about where packages come from.

### Step 3: Record and Communicate your Environment

Once you are ready to share your work, or simply "freeze" it for later, you'll want to make a record of the current environment. 

```{r eval=FALSE}
renv::snapshot()
```

This step creates a new file in your project titled `renv.lock`. The file contains all the information you need to communicate your project's dependencies *at the moment you call `snapshot`*. The next time you call `snapshot`, the file will be updated.

If you are familiar with version control for your code, we recommend calling `snapshot` anytime you push or checkin changes to your code. Learn more about [recording environments with version control](./libraries.html#record-keeping). The `renv::history` and `renv::revert` commands make it easy to navigate and restore prior versions of the lock file.


### Step 4: Recreate the Environment

This step is where the work above pays off! If you need to share your work with others, or need to return to your work after time on other projects, cash in!

```{r eval=FALSE}
# open the project, and use
renv::restore()
```

`renv` will recreate the package environment for you, and you'll be back to working on R code instead of troubleshooting problems!

### Wrap Up

This strategy provides an easy way to start managing R packages for your project. There are many other goals and use cases that might motivate a different strategy or a more complex strategy. Look for your use case!


# What makes up an environment?

Environments can look different in different organizations, but they are composed of common elements. 

```{r fig.cap="Components of an Environment", echo=FALSE}
grViz(
"digraph env {

 graph [layout = dot
        rankdir = BT]
 node [shape = box]
 'Operating System'
 
 node [shape = oval]
 'R Installation'; 'System Libraries'; 'Python Installation'; 'virtualenv'; 'Project Library'
 
 node [shape = egg]
 User
 
 'Operating System' -> 'Python Installation'
 'Operating System' -> 'System Libraries'
 'Operating System' -> 'R Installation'
 'R Installation' -> 'Project Library'
 'System Libraries' -> 'Project Library'
 'System Libraries' -> 'virtualenv'
 virtualenv -> User
 'Project Library' -> User
 'Python Installation' -> virtualenv
}
")

```

If you use a shared server, some elements might be shared amongst projects and
some elements might exist more than once; e.g. your server might have multiple
versions of R installed. If your organization uses Docker containers, you might
have a base image with some of these components, and runtime installation of
others. When you communicate the requirements of your project, it is important to communicate all of the components in play.

- **Operating System** Operating system configurations can be documented with tools like Docker or through Infrastructure-as-code solutions like Chef and Puppet. Often this step is managed outside of the data science team. Learn more about [best practices for Docker](./docker.html).

- **R Installation** Packages like `renv` will normally document the version of R used by the project. On shared servers, it is common to install multiple versions of R. Organizations using Docker will typically include R in a base image. Learn more [best practices for R installations](./R-installation.html).

- **System Dependencies** R, Python, and their packages can depend on underlying software that needs to be installed on the system. For example, the `xml2` R package depends on the `libxml` system package. Learn more about how [system dependencies are documented and managed](./installation.html#system-dependencies).

- **R Packages** Managing and recording R packages makes up the bulk of the website, specifically learn about [repositories](./repositories.html), [installing packages](./installation.html), and [managing libraries](./libraries).

```{r echo=FALSE}
grViz("
digraph repos {
  graph [layout = dot
         rankdir = LR]
  node[shape = box]
  Repository; 'Project Cache'; 'Project 1 Library'; 'Project 2 Library'
  
  'Repository'-> 'Project Cache'
  'Project Cache' -> 'Project 1 Library'
  'Project Cache' -> 'Project 2 Library'
}      
")
```

- **Other Languages** Often data science projects are multi-lingual. Combining R and Python is the most common use case, and tools like `renv` have affordances for recording [Python](./python.html) dependencies.
